import{s as g,B as U}from"./index-DaeIGvco.js";import{p as o}from"./modal-B-hF2fcO.js";const p="127.0.0.1:4000",M="ws";var r=(a=>(a.ERROR="ERROR",a.UserLogin="USER_LOGIN",a.UserLogout="USER_LOGOUT",a.UserExternalLogin="USER_EXTERNAL_LOGIN",a.UserExternalLogout="USER_EXTERNAL_LOGOUT",a.AllAuthenticatedUsers="USER_ACTIVE",a.AllInAuthenticatedUsers="USER_INACTIVE",a.MessageReceived="MSG_SEND",a.MessageHistory="MSG_FROM_USER",a.MessageDeliver="MSG_DELIVER",a.MessageDelete="MSG_DELETE",a.MessageEdit="MSG_EDIT",a.MessageRead="MSG_READ",a))(r||{});function l(a,s,e){try{return JSON.stringify({id:a,type:s,payload:e})}catch(t){return console.error("Error serializing message:",t),""}}class R{socket;roomName;constructor(){this.socket=this.joinBuildWSClient()}sendSocketMessage(s){return new Promise((e,t)=>{if(this.socket&&this.socket.readyState===WebSocket.OPEN)try{this.socket.send(s),e(!0)}catch(i){console.error(i),t(new Error("Error sending message to server"))}else t(new Error("Socket is not open"))})}joinBuildWSClient(){const s=new WebSocket(`${M}://${p}`);return s.onopen=()=>{if(o.publish("connection",{connection:!0}),g.checkUser("user")){const e=g.getUser("user")?.login,t=g.getUser("user")?.password;e&&t&&this.login("id",e,t).catch(()=>{})}},s.onmessage=e=>{this.stateUpdater(e)},s.onclose=()=>{o.publish("error",{error:"Socket is closed. Reconnect will be attempted..."}),setTimeout(()=>{this.socket=this.joinBuildWSClient()},1e3)},s.onerror=e=>{console.error("ws connection error",e),s.close()},s}stateUpdater(s){try{const e=JSON.parse(s.data),{type:t}=e;if(t===r.UserLogin){const{isLogined:i,login:n}=e.payload.user;o.publish("userLoggedIn",{isLogined:i,login:n})}if(t===r.ERROR&&o.publish("error",{error:e.payload.error}),t===r.AllAuthenticatedUsers&&o.publish("usersActive",{users:e.payload.users}),t===r.AllInAuthenticatedUsers&&o.publish("usersInActive",{users:e.payload.users}),t===r.UserExternalLogin){const{isLogined:i,login:n}=e.payload.user;o.publish("userExternalLogin",{isLogined:i,login:n})}if(t===r.UserExternalLogout){const{isLogined:i,login:n}=e.payload.user;o.publish("userExternalLogout",{isLogined:i,login:n})}if(t===r.MessageReceived){const{id:i,text:n,to:h,from:d,datetime:m,status:E}=e.payload.message;o.publish("messageReceived",{id:i,text:n,from:d,to:h,datetime:m,status:E})}t===r.MessageHistory&&o.publish("messageHistory",{messages:e.payload.messages}),t===r.MessageDeliver&&o.publish("messageDeliver",{message:{id:e.payload.message.id,isDelivered:e.payload.message.status.isDelivered}}),t===r.MessageDelete&&o.publish("messageDelete",{message:{id:e.payload.message.id,isDeleted:e.payload.message.status.isDeleted}}),t===r.MessageRead&&o.publish("messageRead",{message:{id:e.payload.message.id,isReaded:e.payload.message.status.isReaded}}),t===r.MessageEdit&&o.publish("messageEdit",{message:{id:e.payload.message.id,text:e.payload.message.text,isEdited:e.payload.message.status.isEdited}})}catch(e){console.error(e)}}login(s,e,t){const i=l(s,r.UserLogin,{user:{login:e,password:t}});return this.sendSocketMessage(i)}logout(s,e,t){const i=l(s,r.UserLogout,{user:{login:e,password:t}});return this.sendSocketMessage(i)}allActiveUsers(s){const e=l(s,r.AllAuthenticatedUsers,null);return this.sendSocketMessage(e)}allInActiveUsers(s){const e=l(s,r.AllInAuthenticatedUsers,null);return this.sendSocketMessage(e)}sendMsg(s,e,t){const i=l(s,r.MessageReceived,{message:{text:e,to:t}});return this.sendSocketMessage(i)}editMsg(s,e,t){const i=l(s,r.MessageEdit,{message:{id:e,text:t}});return this.sendSocketMessage(i)}getHistoryMsg(s,e){const t=l(s,r.MessageHistory,{user:{login:e}});return this.sendSocketMessage(t)}readMsg(s,e){const t=l(s,r.MessageRead,{message:{id:e}});return this.sendSocketMessage(t)}deleteMsg(s,e){const t=l(s,r.MessageDelete,{message:{id:e}});return this.sendSocketMessage(t)}}const c=new R,u="222";class S{login(s,e){c.login(u,s,e).catch(t=>{throw new Error(t.message)})}logout(s,e){c.logout(u,s,e).catch(t=>{throw new Error(t.message)})}allActiveUsers(){c.allActiveUsers(u).catch(()=>{})}allInActiveUsers(){c.allInActiveUsers(u).catch(()=>{})}reLogin=()=>{if(g.checkUser("user")){const s=g.getUser("user")?.login,e=g.getUser("user")?.password;s&&e&&(c.socket.onopen=()=>{this.login(s,e),this.allActiveUsers(),this.allInActiveUsers()})}}}const L=new S;class f extends U{constructor({type:s,className:e,name:t,placeholder:i,value:n,disabled:h,onInput:d}){super({tag:"input",className:e,type:s,placeholder:i,disabled:h}),t&&(this.node.name=t),n&&(this.node.value=n),d&&this.addListener("input",()=>d(this.getValue()))}getValue(){return this.node.value}setValue(s){this.node.value=s}}export{f as I,c as s,L as u};
